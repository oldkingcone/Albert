import socket

class POP3UserEnumeration():
    def __init__(self, target, userlist, port="", scantype="vrfy", mailfrom="root"):
        self.target = target
        self.userlist = userlist
        self.port = port
        self.scantype = scantype
        self.mailfrom = [mailfrom, True]

        self.sock = None
        self.targetBanner = None

    def readUsers(self):
        with open(self.userlist, 'r') as file:
            users = file.read().strip().split('\n')
            self.userlist = users
            return

    def buildSock(self):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((self.target, self.port))
        self.sock = s
        banner = self.sock.recv(1024)[4::]
        if self.targetBanner == None:
            self.targetBanner = banner
            return
    def closeSock(self):
        self.sock.close()
        self.sock = None
        return

    def testScanType(self):
        if self.scantype == "vrfy":
            self.sock.send("VRFY\n")
            response = self.sock.recv(1024)
            self.sock.send("QUIT\n")
            self.closeSock()
            if "501" in response:
                return True
            else:
                return False
        elif self.scantype == "expn":
            self.sock.send("EXPN\n")
            response = self.sock.recv(1024)
            self.sock.send("QUIT\n")
            self.closeSock()
            if "502" in response:
                return False
            else:
                    return True
        elif self.scantype == "rcpt":
            self.sock.send("MAIL FROM:%s\n" %(self.mailfrom[0]))
            self.sock.recv(1024)
            self.sock.send("RCPT TO:%s\n" %(self.mailfrom[0]))
            response = self.sock.recv(1024)
            self.sock.send("QUIT\n")
            self.closeSock()
            if ("250" in response) or ("550" in response):
                return True
            else:
                return False

    def vfryProbe(self, user):
        self.sock.send("VFRY %s\n" %(user))
        response = self.sock.recv(1024)
        if ("250" in response) or ("252" in response):
            return True
        else:
            return False
    def expnProbe(self, user):
        self.sock.send("EXPN %s\n" %(user))
        response = self.sock.recv(1024)
        if "250" in response:
            return True
        else:
            return False

    def rcptProbe(self, user):
        if self.mailfrom[1]:
            self.sock.send("MAIL FROM:%s\n" %(user))
            response = self.sock.recv(1024)
            if "250" in response:
                return True
            else:
                return False

    def probeTarget(self, user):
        if self.scantype == "vrfy":
            result = self.vrfyProbe(user)
        elif self.scantype == "expn":
            result = self.exponProbe(user)
        elif self.scantype == "rcpt":
            result = self.rcptProbe(user)
            return result

    if __name__ == "__main__":
        import os
        import sys
        import argparse
        from datetime import datetime

        parser = argparse.ArgumentParser(description="Some Real SMTP Enumeration Bois")
        parser.add_argument("-t", "--target", help="IP address of target server", action="store", dest="target", default=False)
        parser.add_argument("-p", "--port", help="Port number of target server", action="store", dest="port", default="IP")
        parser.add_argument("-u", "--userlist", help="Path to wordlist", action="store", dest="file", default=False)
        parser.add_argument("--mailfrom", help="Change username used for MAIL FROM command", action="store", dest="user", default="root")
        parser.add_argument("--scan-vrfy", help="User VRFY enumeration", action="store_true", dest="vrfy", default=False)
        parser.add_argument("--scan-expn", help="Use EXPN enumeration method", action="store_true", dest="expn", default=False)
        parser.add_argument("--scan-rcpt", help="Use RCPT enumeration method", action="store_true", dest="rcpt", default=False)
        args = parser.parse_args()

        if len(sys.argv) == 1:
            parser.print_help()  # print help page
            sys.exit(0)  # exit

        if not args.target:
            parser.error("No target IP address given")
            sys.exit(1)
        try:
            socket.inet_aton(args.target)
        except socket.error:
            parser.error("Given target IP address is invalid")  # the given IP is invalid
            sys.exit(1)

        try:
            if (int(args.port) < 1) or (int(args.port) > 65536):  # convert args.port to integer and make sure it fits port range
                raise Exception  # if it doesn't fit the port range, raise an exception
        except:  # if an error is generated by the int conversion (a non-int being entered) or the range doesn't fit
            parser.error("Given target port number is invalid")  # the port number is invalid
            sys.exit(1)

        if not args.file:  # if no wordlist given
            parser.error("No wordlist given")
            sys.exit(1)
        elif not os.path.isfile(args.file):  # if a wordlist was given but doesn't exist
            parser.error("Given wordlist does not exist")
            sys.exit(1)

        types = [args.vrfy, args.expn, args.rcpt]  # put all scan-type values in a list for easier evaluation
        if (types.count(True) > 1) or (types.count(True) == 0):  # if more than 1 True value OR if 0 True values
            parser.error("Scan type selection invalid (choose one)")  # the scan choice is invalid
            sys.exit(1)

        # evaluate scan types in the order they were taken from args
        if types[0]:  # args.vrfy is True
            scantype = "vrfy"  # set scantype to vrfy
        elif types[1]:
            scantype = "expn"
        elif types[2]:
            scantype = "rcpt"

        print("[*] %s scan chosen for use against %s:%s" % (scantype.upper(), args.target, str(args.port)))  # give info on scan back to user
        # create enumerator object and apply all validated input
        enumerator = SMTPUserEnumerator(args.target, args.file, port=int(args.port), scantype=scantype,
                                        mailfrom=args.user)

        print("[*] Checking for vulnerability to %s scan... " % (scantype.upper()))
        sys.stdout.flush()  # begin vuln check
        try:
            enumerator.buildSock()  # build sock to target
            check = enumerator.testScanType()  # call testScanType() and store result in check
            if check:  # if testScanType() returned True
                print("[VULNERABLE]" ) # target is vulnerable
            else:  # if False is returned
                print("[NOT VULNERABLE]")  # target is not vulnerable
                sys.exit(1)
        except Exception:  # if an error happens (bogus target info is entered)
            print("[Try Again!]")  # check failed
            sys.exit(1)  # exit

        print("[*] Parsing list of users... ")
        sys.stdout.flush()  # tell user that file is being read
        try:
            enumerator.readUsers()  # call readUsers() to read, parse, and store file contents
            print("[DONE]")
        except:  # if something goes wrong
            print("[FAIL]")# fail out and exit
            sys.exit(1)

        print("[*] Trying %s users... \n" % (str(len(enumerator.userlist))))  # print number of usernames to try
        startTime = datetime.now()  # start clock for scan duration
        enumerator.buildSock()  # call buildSock() to reconnect to target
        print("Target banner: %s" % (enumerator.targetBanner))  # print target banner taken on vuln check
        for i in range(len(enumerator.userlist)):  # enumerate through usernames
            result = enumerator.probeTarget(enumerator.userlist[i])  # call probeTarget() and pass current username
            if result:  # if its a good username
                print("Found: %s" % (enumerator.userlist[i]))  # report in console
        enumerator.closeSock()  # close connection to target once scan is done
        stopTime = datetime.now()  # stop clock for scan duration

        print("\n[*] Enumeration complete!") # complete scan
        print("[*] Duration: %s" % (str(stopTime - startTime)))  # calculate and print scan duration
